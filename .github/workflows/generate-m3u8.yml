import requests
from bs4 import BeautifulSoup
import os
import re

# ç¦ç”¨ SSL è­¦å‘Š
requests.packages.urllib3.disable_warnings()

# é…ç½®é¡¹
TARGET_URL = "https://epg.51zmt.top:8001/multicast/"
M3U8_OUTPUT_PATH = "tv_channels.m3u8"
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

def fetch_page_content(url):
    """çˆ¬å–ç›®æ ‡é¡µé¢å†…å®¹"""
    try:
        headers = {"User-Agent": USER_AGENT}
        response = requests.get(url, headers=headers, verify=False, timeout=30)
        response.raise_for_status()
        response.encoding = response.apparent_encoding
        return response.text
    except Exception as e:
        print(f"çˆ¬å–é¡µé¢å¤±è´¥ï¼š{e}")
        return None

def parse_channel_info(html_content):
    """è§£æé¡µé¢ï¼ˆé€‚é…çœŸå®çš„divå¸ƒå±€ï¼‰"""
    channels = []
    if not html_content:
        return channels
    
    soup = BeautifulSoup(html_content, "lxml")
    try:
        # ========== æ ¸å¿ƒï¼šé€‚é…ç›®æ ‡é¡µé¢çš„çœŸå®ç»“æ„ ==========
        # æ‰¾åˆ°æ‰€æœ‰é¢‘é“é¡¹çš„å¤–å±‚å®¹å™¨ï¼ˆå®é™…é¡µé¢çš„é¢‘é“é¡¹classä¸º "col-md-3 col-sm-4 col-xs-6"ï¼‰
        channel_items = soup.find_all("div", class_=re.compile(r"col-md-\d+ col-sm-\d+ col-xs-\d+"))
        print(f"æ‰¾åˆ° {len(channel_items)} ä¸ªé¢‘é“é¡¹å®¹å™¨")
        
        for item in channel_items:
            # æå–é¢‘é“åç§°
            name_tag = item.find("h4") or item.find("div", class_="channel-name")
            channel_name = name_tag.get_text(strip=True) if name_tag else ""
            
            # æå–æ’­æ”¾åœ°å€ï¼ˆå›æ”¾/ç›´æ’­åœ°å€ï¼‰
            url_tag = item.find("a", href=True)
            play_url = url_tag["href"].strip() if url_tag else ""
            # è¿‡æ»¤æ— æ•ˆåœ°å€ï¼ˆéhttpå¼€å¤´çš„åœ°å€ï¼‰
            if not play_url.startswith(("http://", "https://")):
                continue
            
            # æå–åˆ†ç»„ï¼ˆæ¯”å¦‚ å¤®è§†ã€å«è§†ã€åœ°æ–¹å° ç­‰ï¼‰
            group_tag = item.find("span", class_="label") or item.find("div", class_="channel-group")
            group = group_tag.get_text(strip=True) if group_tag else "é»˜è®¤åˆ†ç»„"
            
            # æå–å°æ ‡
            logo_tag = item.find("img", class_="img-responsive")
            logo = logo_tag["src"].strip() if logo_tag else ""
            # è¡¥å…¨å°æ ‡ç›¸å¯¹è·¯å¾„
            if logo and not logo.startswith(("http://", "https://")):
                logo = f"https://epg.51zmt.top:8001{logo}"
            
            # è¿‡æ»¤ç©ºåç§°/ç©ºåœ°å€çš„æ— æ•ˆé¢‘é“
            if channel_name and play_url:
                channels.append({
                    "name": channel_name,
                    "url": play_url,
                    "group": group,
                    "logo": logo
                })
        
        print(f"âœ… æˆåŠŸè§£æ {len(channels)} ä¸ªæœ‰æ•ˆé¢‘é“")
    except Exception as e:
        print(f"è§£æé¢‘é“ä¿¡æ¯å¤±è´¥ï¼š{e}")
        import traceback
        traceback.print_exc()  # æ‰“å°è¯¦ç»†é”™è¯¯æ ˆï¼Œæ–¹ä¾¿è°ƒè¯•
    return channels

def generate_m3u8(channels, output_path):
    """ç”Ÿæˆå¸¦åˆ†ç»„ã€å°æ ‡çš„æ ‡å‡† m3u8 æ–‡ä»¶"""
    m3u8_header = (
        "#EXTM3U x-tvg-url=\"https://epg.51zmt.top:8001/xmltv.xml\"\n"
    )
    
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(m3u8_header)
        for channel in channels:
            # å¤„ç†ç©ºå°æ ‡ï¼ˆé¿å…m3u8æ ¼å¼é”™è¯¯ï¼‰
            logo = channel["logo"] if channel["logo"] else ""
            # æ„å»ºEXTINFè¡Œï¼ˆå…¼å®¹æ‰€æœ‰IPTVæ’­æ”¾å™¨ï¼‰
            extinf_line = f"#EXTINF:-1 tvg-name=\"{channel['name']}\" tvg-logo=\"{logo}\" group-title=\"{channel['group']}\",{channel['name']}\n"
            f.write(extinf_line)
            f.write(f"{channel['url']}\n\n")
    print(f"ğŸ“ m3u8 æ–‡ä»¶å·²ç”Ÿæˆï¼š{output_path}ï¼ˆå…± {len(channels)} ä¸ªé¢‘é“ï¼‰")

if __name__ == "__main__":
    # 1. çˆ¬å–é¡µé¢
    html = fetch_page_content(TARGET_URL)
    if not html:
        exit(1)
    
    # 2. è§£æé¢‘é“ä¿¡æ¯
    channels = parse_channel_info(html)
    if not channels:
        print("âŒ æœªè§£æåˆ°ä»»ä½•æœ‰æ•ˆé¢‘é“ä¿¡æ¯")
        exit(1)
    
    # 3. ç”Ÿæˆ m3u8 æ–‡ä»¶
    generate_m3u8(channels, M3U8_OUTPUT_PATH)import requests
from bs4 import BeautifulSoup
import os
import re

# ç¦ç”¨ SSL è­¦å‘Š
requests.packages.urllib3.disable_warnings()

# é…ç½®é¡¹
TARGET_URL = "https://epg.51zmt.top:8001/multicast/"
M3U8_OUTPUT_PATH = "tv_channels.m3u8"
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

def fetch_page_content(url):
    """çˆ¬å–ç›®æ ‡é¡µé¢å†…å®¹"""
    try:
        headers = {"User-Agent": USER_AGENT}
        response = requests.get(url, headers=headers, verify=False, timeout=30)
        response.raise_for_status()
        response.encoding = response.apparent_encoding
        return response.text
    except Exception as e:
        print(f"çˆ¬å–é¡µé¢å¤±è´¥ï¼š{e}")
        return None

def parse_channel_info(html_content):
    """è§£æé¡µé¢ï¼ˆé€‚é…çœŸå®çš„divå¸ƒå±€ï¼‰"""
    channels = []
    if not html_content:
        return channels
    
    soup = BeautifulSoup(html_content, "lxml")
    try:
        # ========== æ ¸å¿ƒï¼šé€‚é…ç›®æ ‡é¡µé¢çš„çœŸå®ç»“æ„ ==========
        # æ‰¾åˆ°æ‰€æœ‰é¢‘é“é¡¹çš„å¤–å±‚å®¹å™¨ï¼ˆå®é™…é¡µé¢çš„é¢‘é“é¡¹classä¸º "col-md-3 col-sm-4 col-xs-6"ï¼‰
        channel_items = soup.find_all("div", class_=re.compile(r"col-md-\d+ col-sm-\d+ col-xs-\d+"))
        print(f"æ‰¾åˆ° {len(channel_items)} ä¸ªé¢‘é“é¡¹å®¹å™¨")
        
        for item in channel_items:
            # æå–é¢‘é“åç§°
            name_tag = item.find("h4") or item.find("div", class_="channel-name")
            channel_name = name_tag.get_text(strip=True) if name_tag else ""
            
            # æå–æ’­æ”¾åœ°å€ï¼ˆå›æ”¾/ç›´æ’­åœ°å€ï¼‰
            url_tag = item.find("a", href=True)
            play_url = url_tag["href"].strip() if url_tag else ""
            # è¿‡æ»¤æ— æ•ˆåœ°å€ï¼ˆéhttpå¼€å¤´çš„åœ°å€ï¼‰
            if not play_url.startswith(("http://", "https://")):
                continue
            
            # æå–åˆ†ç»„ï¼ˆæ¯”å¦‚ å¤®è§†ã€å«è§†ã€åœ°æ–¹å° ç­‰ï¼‰
            group_tag = item.find("span", class_="label") or item.find("div", class_="channel-group")
            group = group_tag.get_text(strip=True) if group_tag else "é»˜è®¤åˆ†ç»„"
            
            # æå–å°æ ‡
            logo_tag = item.find("img", class_="img-responsive")
            logo = logo_tag["src"].strip() if logo_tag else ""
            # è¡¥å…¨å°æ ‡ç›¸å¯¹è·¯å¾„
            if logo and not logo.startswith(("http://", "https://")):
                logo = f"https://epg.51zmt.top:8001{logo}"
            
            # è¿‡æ»¤ç©ºåç§°/ç©ºåœ°å€çš„æ— æ•ˆé¢‘é“
            if channel_name and play_url:
                channels.append({
                    "name": channel_name,
                    "url": play_url,
                    "group": group,
                    "logo": logo
                })
        
        print(f"âœ… æˆåŠŸè§£æ {len(channels)} ä¸ªæœ‰æ•ˆé¢‘é“")
    except Exception as e:
        print(f"è§£æé¢‘é“ä¿¡æ¯å¤±è´¥ï¼š{e}")
        import traceback
        traceback.print_exc()  # æ‰“å°è¯¦ç»†é”™è¯¯æ ˆï¼Œæ–¹ä¾¿è°ƒè¯•
    return channels

def generate_m3u8(channels, output_path):
    """ç”Ÿæˆå¸¦åˆ†ç»„ã€å°æ ‡çš„æ ‡å‡† m3u8 æ–‡ä»¶"""
    m3u8_header = (
        "#EXTM3U x-tvg-url=\"https://epg.51zmt.top:8001/xmltv.xml\"\n"
    )
    
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(m3u8_header)
        for channel in channels:
            # å¤„ç†ç©ºå°æ ‡ï¼ˆé¿å…m3u8æ ¼å¼é”™è¯¯ï¼‰
            logo = channel["logo"] if channel["logo"] else ""
            # æ„å»ºEXTINFè¡Œï¼ˆå…¼å®¹æ‰€æœ‰IPTVæ’­æ”¾å™¨ï¼‰
            extinf_line = f"#EXTINF:-1 tvg-name=\"{channel['name']}\" tvg-logo=\"{logo}\" group-title=\"{channel['group']}\",{channel['name']}\n"
            f.write(extinf_line)
            f.write(f"{channel['url']}\n\n")
    print(f"ğŸ“ m3u8 æ–‡ä»¶å·²ç”Ÿæˆï¼š{output_path}ï¼ˆå…± {len(channels)} ä¸ªé¢‘é“ï¼‰")

if __name__ == "__main__":
    # 1. çˆ¬å–é¡µé¢
    html = fetch_page_content(TARGET_URL)
    if not html:
        exit(1)
    
    # 2. è§£æé¢‘é“ä¿¡æ¯
    channels = parse_channel_info(html)
    if not channels:
        print("âŒ æœªè§£æåˆ°ä»»ä½•æœ‰æ•ˆé¢‘é“ä¿¡æ¯")
        exit(1)
    
    # 3. ç”Ÿæˆ m3u8 æ–‡ä»¶
    generate_m3u8(channels, M3U8_OUTPUT_PATH)import requests
from bs4 import BeautifulSoup
import os
import re

# ç¦ç”¨ SSL è­¦å‘Š
requests.packages.urllib3.disable_warnings()

# é…ç½®é¡¹
TARGET_URL = "https://epg.51zmt.top:8001/multicast/"
M3U8_OUTPUT_PATH = "tv_channels.m3u8"
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

def fetch_page_content(url):
    """çˆ¬å–ç›®æ ‡é¡µé¢å†…å®¹"""
    try:
        headers = {"User-Agent": USER_AGENT}
        response = requests.get(url, headers=headers, verify=False, timeout=30)
        response.raise_for_status()
        response.encoding = response.apparent_encoding
        return response.text
    except Exception as e:
        print(f"çˆ¬å–é¡µé¢å¤±è´¥ï¼š{e}")
        return None

def parse_channel_info(html_content):
    """è§£æé¡µé¢ï¼ˆé€‚é…çœŸå®çš„divå¸ƒå±€ï¼‰"""
    channels = []
    if not html_content:
        return channels
    
    soup = BeautifulSoup(html_content, "lxml")
    try:
        # ========== æ ¸å¿ƒï¼šé€‚é…ç›®æ ‡é¡µé¢çš„çœŸå®ç»“æ„ ==========
        # æ‰¾åˆ°æ‰€æœ‰é¢‘é“é¡¹çš„å¤–å±‚å®¹å™¨ï¼ˆå®é™…é¡µé¢çš„é¢‘é“é¡¹classä¸º "col-md-3 col-sm-4 col-xs-6"ï¼‰
        channel_items = soup.find_all("div", class_=re.compile(r"col-md-\d+ col-sm-\d+ col-xs-\d+"))
        print(f"æ‰¾åˆ° {len(channel_items)} ä¸ªé¢‘é“é¡¹å®¹å™¨")
        
        for item in channel_items:
            # æå–é¢‘é“åç§°
            name_tag = item.find("h4") or item.find("div", class_="channel-name")
            channel_name = name_tag.get_text(strip=True) if name_tag else ""
            
            # æå–æ’­æ”¾åœ°å€ï¼ˆå›æ”¾/ç›´æ’­åœ°å€ï¼‰
            url_tag = item.find("a", href=True)
            play_url = url_tag["href"].strip() if url_tag else ""
            # è¿‡æ»¤æ— æ•ˆåœ°å€ï¼ˆéhttpå¼€å¤´çš„åœ°å€ï¼‰
            if not play_url.startswith(("http://", "https://")):
                continue
            
            # æå–åˆ†ç»„ï¼ˆæ¯”å¦‚ å¤®è§†ã€å«è§†ã€åœ°æ–¹å° ç­‰ï¼‰
            group_tag = item.find("span", class_="label") or item.find("div", class_="channel-group")
            group = group_tag.get_text(strip=True) if group_tag else "é»˜è®¤åˆ†ç»„"
            
            # æå–å°æ ‡
            logo_tag = item.find("img", class_="img-responsive")
            logo = logo_tag["src"].strip() if logo_tag else ""
            # è¡¥å…¨å°æ ‡ç›¸å¯¹è·¯å¾„
            if logo and not logo.startswith(("http://", "https://")):
                logo = f"https://epg.51zmt.top:8001{logo}"
            
            # è¿‡æ»¤ç©ºåç§°/ç©ºåœ°å€çš„æ— æ•ˆé¢‘é“
            if channel_name and play_url:
                channels.append({
                    "name": channel_name,
                    "url": play_url,
                    "group": group,
                    "logo": logo
                })
        
        print(f"âœ… æˆåŠŸè§£æ {len(channels)} ä¸ªæœ‰æ•ˆé¢‘é“")
    except Exception as e:
        print(f"è§£æé¢‘é“ä¿¡æ¯å¤±è´¥ï¼š{e}")
        import traceback
        traceback.print_exc()  # æ‰“å°è¯¦ç»†é”™è¯¯æ ˆï¼Œæ–¹ä¾¿è°ƒè¯•
    return channels

def generate_m3u8(channels, output_path):
    """ç”Ÿæˆå¸¦åˆ†ç»„ã€å°æ ‡çš„æ ‡å‡† m3u8 æ–‡ä»¶"""
    m3u8_header = (
        "#EXTM3U x-tvg-url=\"https://epg.51zmt.top:8001/xmltv.xml\"\n"
    )
    
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(m3u8_header)
        for channel in channels:
            # å¤„ç†ç©ºå°æ ‡ï¼ˆé¿å…m3u8æ ¼å¼é”™è¯¯ï¼‰
            logo = channel["logo"] if channel["logo"] else ""
            # æ„å»ºEXTINFè¡Œï¼ˆå…¼å®¹æ‰€æœ‰IPTVæ’­æ”¾å™¨ï¼‰
            extinf_line = f"#EXTINF:-1 tvg-name=\"{channel['name']}\" tvg-logo=\"{logo}\" group-title=\"{channel['group']}\",{channel['name']}\n"
            f.write(extinf_line)
            f.write(f"{channel['url']}\n\n")
    print(f"ğŸ“ m3u8 æ–‡ä»¶å·²ç”Ÿæˆï¼š{output_path}ï¼ˆå…± {len(channels)} ä¸ªé¢‘é“ï¼‰")

if __name__ == "__main__":
    # 1. çˆ¬å–é¡µé¢
    html = fetch_page_content(TARGET_URL)
    if not html:
        exit(1)
    
    # 2. è§£æé¢‘é“ä¿¡æ¯
    channels = parse_channel_info(html)
    if not channels:
        print("âŒ æœªè§£æåˆ°ä»»ä½•æœ‰æ•ˆé¢‘é“ä¿¡æ¯")
        exit(1)
    
    # 3. ç”Ÿæˆ m3u8 æ–‡ä»¶
    generate_m3u8(channels, M3U8_OUTPUT_PATH)import requests
from bs4 import BeautifulSoup
import os
import re

# ç¦ç”¨ SSL è­¦å‘Š
requests.packages.urllib3.disable_warnings()

# é…ç½®é¡¹
TARGET_URL = "https://epg.51zmt.top:8001/multicast/"
M3U8_OUTPUT_PATH = "tv_channels.m3u8"
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

def fetch_page_content(url):
    """çˆ¬å–ç›®æ ‡é¡µé¢å†…å®¹"""
    try:
        headers = {"User-Agent": USER_AGENT}
        response = requests.get(url, headers=headers, verify=False, timeout=30)
        response.raise_for_status()
        response.encoding = response.apparent_encoding
        return response.text
    except Exception as e:
        print(f"çˆ¬å–é¡µé¢å¤±è´¥ï¼š{e}")
        return None

def parse_channel_info(html_content):
    """è§£æé¡µé¢ï¼ˆé€‚é…çœŸå®çš„divå¸ƒå±€ï¼‰"""
    channels = []
    if not html_content:
        return channels
    
    soup = BeautifulSoup(html_content, "lxml")
    try:
        # ========== æ ¸å¿ƒï¼šé€‚é…ç›®æ ‡é¡µé¢çš„çœŸå®ç»“æ„ ==========
        # æ‰¾åˆ°æ‰€æœ‰é¢‘é“é¡¹çš„å¤–å±‚å®¹å™¨ï¼ˆå®é™…é¡µé¢çš„é¢‘é“é¡¹classä¸º "col-md-3 col-sm-4 col-xs-6"ï¼‰
        channel_items = soup.find_all("div", class_=re.compile(r"col-md-\d+ col-sm-\d+ col-xs-\d+"))
        print(f"æ‰¾åˆ° {len(channel_items)} ä¸ªé¢‘é“é¡¹å®¹å™¨")
        
        for item in channel_items:
            # æå–é¢‘é“åç§°
            name_tag = item.find("h4") or item.find("div", class_="channel-name")
            channel_name = name_tag.get_text(strip=True) if name_tag else ""
            
            # æå–æ’­æ”¾åœ°å€ï¼ˆå›æ”¾/ç›´æ’­åœ°å€ï¼‰
            url_tag = item.find("a", href=True)
            play_url = url_tag["href"].strip() if url_tag else ""
            # è¿‡æ»¤æ— æ•ˆåœ°å€ï¼ˆéhttpå¼€å¤´çš„åœ°å€ï¼‰
            if not play_url.startswith(("http://", "https://")):
                continue
            
            # æå–åˆ†ç»„ï¼ˆæ¯”å¦‚ å¤®è§†ã€å«è§†ã€åœ°æ–¹å° ç­‰ï¼‰
            group_tag = item.find("span", class_="label") or item.find("div", class_="channel-group")
            group = group_tag.get_text(strip=True) if group_tag else "é»˜è®¤åˆ†ç»„"
            
            # æå–å°æ ‡
            logo_tag = item.find("img", class_="img-responsive")
            logo = logo_tag["src"].strip() if logo_tag else ""
            # è¡¥å…¨å°æ ‡ç›¸å¯¹è·¯å¾„
            if logo and not logo.startswith(("http://", "https://")):
                logo = f"https://epg.51zmt.top:8001{logo}"
            
            # è¿‡æ»¤ç©ºåç§°/ç©ºåœ°å€çš„æ— æ•ˆé¢‘é“
            if channel_name and play_url:
                channels.append({
                    "name": channel_name,
                    "url": play_url,
                    "group": group,
                    "logo": logo
                })
        
        print(f"âœ… æˆåŠŸè§£æ {len(channels)} ä¸ªæœ‰æ•ˆé¢‘é“")
    except Exception as e:
        print(f"è§£æé¢‘é“ä¿¡æ¯å¤±è´¥ï¼š{e}")
        import traceback
        traceback.print_exc()  # æ‰“å°è¯¦ç»†é”™è¯¯æ ˆï¼Œæ–¹ä¾¿è°ƒè¯•
    return channels

def generate_m3u8(channels, output_path):
    """ç”Ÿæˆå¸¦åˆ†ç»„ã€å°æ ‡çš„æ ‡å‡† m3u8 æ–‡ä»¶"""
    m3u8_header = (
        "#EXTM3U x-tvg-url=\"https://epg.51zmt.top:8001/xmltv.xml\"\n"
    )
    
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(m3u8_header)
        for channel in channels:
            # å¤„ç†ç©ºå°æ ‡ï¼ˆé¿å…m3u8æ ¼å¼é”™è¯¯ï¼‰
            logo = channel["logo"] if channel["logo"] else ""
            # æ„å»ºEXTINFè¡Œï¼ˆå…¼å®¹æ‰€æœ‰IPTVæ’­æ”¾å™¨ï¼‰
            extinf_line = f"#EXTINF:-1 tvg-name=\"{channel['name']}\" tvg-logo=\"{logo}\" group-title=\"{channel['group']}\",{channel['name']}\n"
            f.write(extinf_line)
            f.write(f"{channel['url']}\n\n")
    print(f"ğŸ“ m3u8 æ–‡ä»¶å·²ç”Ÿæˆï¼š{output_path}ï¼ˆå…± {len(channels)} ä¸ªé¢‘é“ï¼‰")

if __name__ == "__main__":
    # 1. çˆ¬å–é¡µé¢
    html = fetch_page_content(TARGET_URL)
    if not html:
        exit(1)
    
    # 2. è§£æé¢‘é“ä¿¡æ¯
    channels = parse_channel_info(html)
    if not channels:
        print("âŒ æœªè§£æåˆ°ä»»ä½•æœ‰æ•ˆé¢‘é“ä¿¡æ¯")
        exit(1)
    
    # 3. ç”Ÿæˆ m3u8 æ–‡ä»¶
    generate_m3u8(channels, M3U8_OUTPUT_PATH)
